// 2024-06-24 15:46:10
#event properties (no comments/etc. here are saved)
parent_index = -1;
persistent = true;
uses_physics = false;

#event create
// Settables

scale = 0.03;
padding = 8;
bg_dim = 0.85;
draw_map_data = true;
cam_x = -400;
cam_y = -400;
cam_border_x = -600;
cam_border_y = -800;
cam_border_x2 = 9600 + 600;
cam_border_y2 = 3648 + 600;
crosshair_size = 4;
crosshair_inset = 3;
cam_border_visible_inset = 0;
width = 160;
height = 160;
target_width = 160;
target_height = 160;
initial_width = width;
initial_height = height;
font = fP2Silver16;
hint_font = fP2Silver32;
world_border_path = pP2WorldBorder;
world_border_triangles = scrP2TriangulatePolygon(world_border_path);
level_border_path = pP2LevelBorder;
level_border_triangles = scrP2TriangulatePolygon(level_border_path);
objective_rooms = ds_list_create();

enum P2_MAP_DRAW_MODE {
    MAP,
    NOTHING,
    HINT
}
draw_mode = P2_MAP_DRAW_MODE.MAP;

// Internals
resizing = false;
rooms = scrSynthIterMapCreate();
current_room = "";
current_room_alpha = -1;
objective_room = undefined;
objective_room_alpha = -1;
surf = -1;
player_x = 0;
player_y = 0;

// Shader effect
sh = shP2Kaleidoscope;
sh_time = 0;
sh_col_a_r = 0;
sh_col_a_g = 135 / 255;
sh_col_a_b = 242 / 255;
sh_col_a_a = 0.5;
sh_col_b_r = 183 / 255;
sh_col_b_g = 0;
sh_col_b_b = 205 / 255;
sh_col_b_a = 0.5;

TweenFire(id, EaseInOutQuad, TWEEN_MODE_PATROL, true, 0.0, 1.0, "current_room_alpha", 0.5, 0.1);
TweenFire(id, EaseLinear, TWEEN_MODE_LOOP, true, 0.0, 1.0, "objective_room_alpha", 0.75, 0.25);

_x_tween = noone;
_y_tween = noone;

#event destroy

ds_list_destroy(objective_rooms);
ds_list_destroy(world_border_triangles);
ds_list_destroy(level_border_triangles);
ds_list_destroy(rooms);

if (surface_exists(surf))
    surface_free(surf);

#event step_end|checks player pos, assigns map side

with (objPlayer) {
    other.player_x = x;
    other.player_y = y;
}

#event other_room_start|OPTIONAL: checks kid position from the get go, assigns map location

with (objPlayer) {
    other.player_x = x;
    other.player_y = y;
}

#event other_user0 init
scrP2ObjectivesUpdateRegisterCallback(id, 1);
event_user(1);

#event other_user1
ds_list_clear(objective_rooms);

var
_objectives = scrP2ObjectivesGet(),
_objective_room, _room;

for (var i = 0, n = ds_list_size(_objectives); i < n; i++) {
    _objective_room = ds_map_find_value(ds_list_find_value(_objectives, i), "room");
    for (var j = 0, keys = scrSynthIterMapGetKeys(rooms), key_num = ds_list_size(keys); j < key_num; j++) {
        _room = ds_map_find_value(rooms, ds_list_find_value(keys, j));
        if (ds_map_find_value(_room, "n") == _objective_room) {
            ds_list_add(objective_rooms, _room);
            break;
        }
    }
}

#event draw_gui


resizing = false;

if ((surface_get_width(surf) != width or surface_get_height(surf) != height) && surface_exists(surf))
{
    surface_free(surf);
    resizing = true;
}

if (!surface_exists(surf))
{
    surf = surface_create(width, height);
}

surface_set_target(surf);

var
_x = 0,
_y = 0,
_x2 = _x + width,
_y2 = _y + height,
_cbx2 = cam_border_x2 - width / scale,
_cby2 = cam_border_y2 - height / scale,
_cam_x,
_cam_y;

if (cam_border_x > _cbx2) {
    _cam_x = lerp(cam_border_x, _cbx2, 0.5);
} else {
    _cam_x = clamp(cam_x, cam_border_x, _cbx2);
}

if (cam_border_y > _cby2) {
    _cam_y = lerp(cam_border_y, _cby2, 0.5);
} else {
    _cam_y = clamp(cam_y, cam_border_y, _cby2);
}

draw_set_alpha(bg_dim);
draw_set_color(c_black);
draw_rectangle(_x, _y, _x2, _y2, false);
draw_set_color(c_white);
draw_set_alpha(1.0);

sh_time += (1/50);
shader_set(sh);
shader_set_uniform_f(shader_get_uniform(sh, "time"), sh_time);
shader_set_uniform_f(shader_get_uniform(sh, "col_a"), sh_col_a_r, sh_col_a_g, sh_col_a_b, sh_col_a_a);
shader_set_uniform_f(shader_get_uniform(sh, "col_b"), sh_col_b_r, sh_col_b_g, sh_col_b_b, sh_col_a_b);
shader_set_uniform_f(shader_get_uniform(sh, "size"), initial_width, initial_width);
shader_set_uniform_f(shader_get_uniform(sh, "middle"), width / 2.0, height / 2.0);
draw_rectangle(0, 0, width, height, false);
shader_reset();

switch (draw_mode)
{
    case P2_MAP_DRAW_MODE.MAP:
    {
    if (draw_map_data) {
        var _border_path, _border_triangles;
        if (int_get_bit(global.p2Flag, P2_FLAG.OOB_DISCOVERED)) {
            _border_path = world_border_path;
            _border_triangles = world_border_triangles;
        } else {
            _border_path = level_border_path;
            _border_triangles = level_border_triangles;
        }
        
        draw_set_alpha(bg_dim);
        draw_set_color(c_black);
        draw_set_blend_mode_ext(bm_one, bm_zero);
        draw_primitive_begin(pr_trianglelist);
        for (var i = 0, n = ds_list_size(_border_triangles); i < n; i += 3) {
            draw_vertex(
                (path_get_point_x(_border_path, ds_list_find_value(_border_triangles, i)) - _cam_x) * scale,
                (path_get_point_y(_border_path, ds_list_find_value(_border_triangles, i)) - _cam_y) * scale);
            draw_vertex(
                (path_get_point_x(_border_path, ds_list_find_value(_border_triangles, i + 1)) - _cam_x) * scale,
                (path_get_point_y(_border_path, ds_list_find_value(_border_triangles, i + 1)) - _cam_y) * scale);
            draw_vertex(
                (path_get_point_x(_border_path, ds_list_find_value(_border_triangles, i + 2)) - _cam_x) * scale,
                (path_get_point_y(_border_path, ds_list_find_value(_border_triangles, i + 2)) - _cam_y) * scale);
        }
        draw_primitive_end();
        draw_set_color(c_white);
        draw_set_alpha(1.0);
        draw_set_blend_mode(bm_normal);
        
        if (!is_undefined(rooms[?current_room]))
        {
            var
            _room = rooms[?current_room],
            _rx = _x + (_room[?"x"] - _cam_x) * scale,
            _ry = _y + (_room[?"y"] - _cam_y) * scale,
            _rx2 = _x + (_room[?"x"] + _room[?"w"] - _cam_x) * scale,
            _ry2 = _y + (_room[?"y"] + _room[?"h"] - _cam_y) * scale;
            
            var _cx, _cy;
            _cx = _rx + crosshair_inset;
            _cy = _ry + crosshair_inset;
            draw_line(_cx, _cy, _cx + crosshair_size, _cy);
            draw_line(_cx, _cy, _cx, _cy + crosshair_size);
            _cx = _rx2 - crosshair_inset;
            draw_line(_cx, _cy, _cx - crosshair_size, _cy);
            draw_line(_cx, _cy, _cx, _cy + crosshair_size);
            _cy = _ry2 - crosshair_inset;
            draw_line(_cx, _cy, _cx - crosshair_size, _cy);
            draw_line(_cx, _cy, _cx, _cy - crosshair_size);
            _cx = _rx + crosshair_inset;
            draw_line(_cx, _cy, _cx + crosshair_size, _cy);
            draw_line(_cx, _cy, _cx, _cy - crosshair_size);
            
            draw_set_color(c_red);
            draw_circle(_rx + player_x * scale, _ry + player_y * scale, 2, false);
            draw_set_color(c_white);
        }
        
        for (var i = 0, n = ds_list_size(objective_rooms); i < n; i++) {
            _room = ds_list_find_value(objective_rooms, i);
            draw_set_color(c_yellow);
            draw_set_alpha(objective_room_alpha);
            draw_rectangle(
                _x + (_room[?"x"] - _cam_x) * scale,
                _y + (_room[?"y"] - _cam_y) * scale,
                _x + (_room[?"x"] + _room[?"w"] - _cam_x) * scale,
                _y + (_room[?"y"] + _room[?"h"] - _cam_y) * scale,
                false);
            draw_set_color(c_white);
            draw_set_alpha(1);
        }
        
        for (var i = 0, keys = scrSynthIterMapGetKeys(rooms), n = ds_list_size(keys); i < n; i++)
        {   
            _room = rooms[?keys[|i]];
            draw_rectangle(
                _x + (_room[?"x"] - _cam_x) * scale,
                _y + (_room[?"y"] - _cam_y) * scale,
                _x + (_room[?"x"] + _room[?"w"] - _cam_x) * scale,
                _y + (_room[?"y"] + _room[?"h"] - _cam_y) * scale,
                true);
        }
        
        if (int_get_bit(global.p2Flag, P2_FLAG.OOB_DISCOVERED)) {
        draw_set_color(c_red);
            for (var i = 0, n = path_get_number(world_border_path) - 1; i < n; i++) {
                draw_line(
                    (path_get_point_x(world_border_path, i) - _cam_x) * scale,
                    (path_get_point_y(world_border_path, i) - _cam_y) * scale,
                    (path_get_point_x(world_border_path, i + 1) - _cam_x) * scale,
                    (path_get_point_y(world_border_path, i + 1) - _cam_y) * scale);
            }
        }
        draw_set_color(c_yellow);
        for (var i = 0, n = path_get_number(level_border_path) - 1; i < n; i++) {
            draw_line(
                (path_get_point_x(level_border_path, i) - _cam_x) * scale,
                (path_get_point_y(level_border_path, i) - _cam_y) * scale,
                (path_get_point_x(level_border_path, i + 1) - _cam_x) * scale,
                (path_get_point_y(level_border_path, i + 1) - _cam_y) * scale);
        }
        draw_set_alpha(1);
    }
    
    draw_set_font(font);
    draw_set_color(c_black);
    draw_set_valign(fa_top);
    draw_set_halign(fa_left);
    draw_text(7, 5, current_room);
    draw_set_color(c_white);
    draw_text(6, 4, current_room);
    }
    break;
    
    case P2_MAP_DRAW_MODE.NOTHING:
    break;
    
    case P2_MAP_DRAW_MODE.HINT:
    // TODO: Make this remappable
    draw_set_font(hint_font);
    draw_set_valign(fa_middle);
    draw_set_halign(fa_center);
    draw_text(_x + target_width / 2.0 + 1, _y + target_height / 2.0 + 5, scrGetKeybind(ord("X")));
    draw_set_valign(fa_top);
    draw_set_halign(fa_left);
    break;
}

scrP2DrawAnimatedRectangle(_x, _y, width - 1 - resizing, height - 1 - resizing, 1.0);

surface_reset_target();

draw_surface_ext(surf, view_wview[0] - padding - width, padding, 1, 1, image_angle, image_blend, image_alpha);
